# 迷宫逃脱任务

## 简介

欢迎来到本单元的最后一个编程任务！在这次作业中，你将使用抽象数据类型 (ADT)、算法和递归，帮助你找到逃出迷宫的路径。

## 限制和假设

- **允许的导入**：你可以导入任何算法或数据结构，但不能对它们进行修改。
- **排序限制**：你不能使用任何未提供的排序算法，包括 Python 内置的排序函数（例如：`sorted`、`.sort`）。

⚠️ **重要提示**：违反上述规则中的任何一条，将被视为严重错误，可能导致该任务成绩的 100% 扣分。

## 重要说明

在完成作业过程中，你可能会发现你之前使用的 ADT 选择并不理想。因此，优化解决方案或让代码更优雅时，回头修改是非常重要的。记住，你的评分标准包含复杂度和 ADT 的选择。

### 复杂度注意事项

某些任务对时间复杂度有明确要求。如果未达到这些复杂度要求，将导致较低的评分。

## 迷宫表示

- 迷宫是由字符组成的二维列表，其中包含以下字符：
  - `P`：玩家（你）
  - `E`：出口
  - `#`：墙壁
  - `M`：神秘洞穴
  - `S`：诡异洞穴
  - 空格（或在文本文件中用`.`表示）：空地

### 复杂度分析

- `n` 是迷宫中的行数
- `m` 是迷宫中的列数

### 迷宫示例

```python
[
    ['#', 'S', '#', '#'],
    ['#', 'P', ' ', '#'],
    ['#', ' ', '#', 'M'],
    ['#', ' ', ' ', 'E'],
    ['E', '#', '#', '#']
]
```

在该迷宫中：

- 玩家位置：`(1, 1)`
- 出口位置：`(3, 3)` 和 `(4, 0)`
- 洞穴位置：`(0, 1)` 和 `(2, 3)`
- 总共 20 个格子（5 行 x 4 列）

## 玩家移动规则

- **移动方向**：玩家只能水平或垂直移动，不能对角移动。
- **有效移动**：玩家只能移动到空地或出口。
- **障碍物**：玩家不能移动到墙 (`#`) 上。
- **边界**：玩家不能移动到迷宫边界之外。
- **出口**：一旦玩家移动到出口位置，立即离开迷宫。

## 洞穴

- 洞穴 (`M`、`S`) 中藏有宝藏。
- **移动**：玩家可以穿越或站在洞穴格子上。
- **宝藏**：每个洞穴只能拾取一个宝藏���

## 任务 1 - 内部平衡（修改 `betterbst.py`）

### 目标

创建一个“更好的”二叉搜索树 (BST)，根据提前给定的元素构建平衡树。你将需要在 `BetterBST` 类中实现两个方法：

### 1. `__sort_elements(self, elements: list[Tuple[K, I]]) -> list[I]`

- 该方法根据 key 对元素列表进行排序，返回排序后的元素列表。
- 示例：
  - 输入：`[5, 3, 1, 7]`
  - 输出（升序）：`[1, 3, 5, 7]`

### 2. `__build_balanced_tree(self, elements: list[Tuple[K, I]])`

- 该方法使用排序后的元素构建平衡的 BST。
- 确保树的高度为 ⌈log₂n⌉。

### 复杂度要求

- **最佳和最坏情况**：两个方法的时间复杂度均需为 `O(n log n)`，其中 `n` 为树中节点的数量。

## 任务 2 - 探索洞穴！（修改 `hollows.py`）

在 `MysticalHollow` 和 `SpookyHollow` 类中实现两个方法，以选择最优的宝藏。

### 1. `restructure_hollow(self) -> None`

- 将洞穴中的宝藏重新排列成更高效的数据结构。

### 2. `get_optimal_treasure(self, backpack_capacity: int) -> Treasure | None`

- 选择价值/重量比最高的宝藏，但总重量不能超过玩家背包的容量。

### 2目标

- **SpookyHollow**:
  - 时间复杂度：
    - **最佳情况**：`O(log n)`
    - **最坏情况**：`O(n)`
- **MysticalHollow**：
  - 时间复杂度：
    - **最佳情况**：`O(log n)`
    - **最坏情况**：`O(n log n)`

## 任务 3 - 逃出迷宫！（修改 `maze.py`）

### 3目标

使用深度优先搜索 (DFS) 找到从玩家起点到出口的一条有效路径。

### 方法

#### 1. `find_way_out(self) -> tuple[list[MazeCell], int] | None`

- **输出**：返回从起点到出口的路径，或如果没有有效路径，返回 `None`。
- 必须递归实现，才能获得完整评分。

#### 2. `is_valid_position(self, position: Position) -> bool`

- 检查一个位置是否在迷宫范围内，并且是否是有效的移动位置。

#### 3. `get_available_positions(self, current_position: Position) -> list[Position]`

- 返回玩家当前可以移动到的有效邻居位置列表。

#### 4. `take_treasures(self, path: list[MazeCell], backpack_capacity: int) -> list[Treasure] | None`

- **目标**：从有效路径中遇到的洞穴中选取宝藏，确保总重量不超过背包容量。
- 宝藏按路径遇到的顺序选择，优先选择价值/重量比最高的宝藏。
- **输出**：返回选取的宝藏列表，或如果没有宝藏被选取，返回 `None`。

### 其他考虑

- 使用深度优先搜索 (DFS) 进行路径搜索。
- 你不需要找到最短路径，只需找到一条有效路径即可。

## 结论

这次作业涉及优化 ADT 的使用，算法的实现以及使用递归的深度优先搜索来找到迷宫出口和管理宝藏。请注意时间复杂度和规则限制，以最大化得分。
